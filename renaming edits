.data
# Common format strings and labels for output
newLineChar:     .asciiz "\n"                        # Newline for output separation
spaceChar:       .asciiz " "                         # Space for formatting output
inputHandler:    .space 500                          # Buffer for holding each line from the input file
outputHandler:   .space 128
generalHandler:     .space 12

# Buffers and labels for user prompts and inputs
printUserFileName:    .asciiz "Dear user, please enter the input file name: " # Prompt for input file name
fileNameInputHandler:       .space 64                       # Buffer for storing input file name
choiceFlag:   .space 2                         # Buffer to store the output choice flag
invalidChoiceHandler: .asciiz "Error: You have enered wrong choice, exiting program.\n"
fileNameOutputHandler: .asciiz "Dear user, please enter the output: "
outFileNameHandler:      .space 64                       # Buffer for storing output file name

# Error messages for common issues
erroReadingFile:      .asciiz "Error: There is a problem with reading the file :) \n"
divisionByZero:       .asciiz "Error: There is a division by zero issue here!\n"
equationErrorFormat:         .asciiz "Error: There is an issue with the format of the equations\n" # Error for format issues

# Equation formatting labels
XLabel:         .asciiz "X"
YLabel:         .asciiz "Y"
ZLabel:         .asciiz "Z"
SysLabel:    .asciiz "System "
resLabel:    .asciiz "Equation: "
pluseOp:   .asciiz "+"
minusOp:  .asciiz "-"
equalsOp: .asciiz " = "
divideOp: .asciiz "/"
readX:	     .byte 0
readY:          .byte 0
readZ:          .byte 0
reachEqual:     .byte 0


# Coefficient arrays and result storage for parsed equations
XsCoeff:   .space 30                            # Array to hold coefficients for 'x' in multiple systems
YsCoeff:   .space 30                            # Array to hold coefficients for 'y' in multiple systems
ZsCoeff:   .space 30                            # Array to hold coefficients for 'z' in multiple systems
resultedArray:   .space 30                            # Array to store the right-hand side results of equations
isIt2or3Vars: .space 30                          # Array to indicate if equation is 2 or 3 variable system

# Variables for tracking systems and results
sysCounter:     .byte 0                           # Counter for the number of systems processed
FlagInputFile:    .space 2		      # Flag for tracking if user inputted a file or not

# Error messages and prompts for enhanced feedback
readInputFileFIRST:     .asciiz "Dear user, please focus! you need to read an input file first!\n"

# User Menu Prompt
menuToUser:    .asciiz "Dear our expensive user, please choose an option:\n1 - Read input file\n2 - f or F for output to file\n3 - s or S for console output\n4 - e or E to exit\nChoice: "
menuChoice:    .space 2                             # Buffer to store menu choice input

A_Determinant:	    .word 0
A1_Determinant:	    .word 0
A2_Determinant:	    .word 0
A3_Determinant:         .word 0

.text
.globl main

.macro MOVE_MEM $src, $dest
    sb $src, 0($dest)
    addiu $dest, $dest, 1
.end_macro

.macro PRINT_VAR_RES $src, $dest
    MOVE_MEM $src, $dest
    li $src, ' '
    MOVE_MEM $src, $dest
    li $src, '='
    MOVE_MEM $src, $dest
    li $src, ' '
    MOVE_MEM $src, $dest
.end_macro

main:
    # Display the main menu and handle user input
display_menu:
    # Print the menu prompt
    li $v0, 4                                 # Syscall for print string
    la $a0, menuToUser                       # Load address of the menu prompt
    syscall

    # Read menu choice from user
    li $v0, 8                                 # Syscall for reading a string
    la $a0, menuChoice                       # Buffer to store the user's menu choice
    li $a1, 2                                 # Limit the input to 1 character
    syscall
    
    la $a0, newLineChar
    li $v0, 4
    syscall
    
    # Process the user menu choice
    lb $t7, menuChoice                       # Load the user's choice into $t7
    li $t6, '1'                               # ASCII code for '1'
    beq $t7, $t6, handle_read_input           # If choice is '1', go to file reading section

    li $t6, '2'                               # ASCII code for '2'
    beq $t7, $t6, handle_output_file          # If choice is '2', go to output to file handling

    li $t6, 'f'                               # ASCII for lowercase 'f'
    beq $t7, $t6, handle_output_file          # If choice is 'f', handle file output

    li $t6, 'F'                               # ASCII for uppercase 'F'
    beq $t7, $t6, handle_output_file          # If choice is 'F', handle file output

    li $t6, '3'                               # ASCII code for '3'
    beq $t7, $t6, handle_screen_output        # If choice is '3', handle screen output

    li $t6, 's'                               # ASCII for lowercase 's'
    beq $t7, $t6, handle_screen_output        # If choice is 's', handle screen output

    li $t6, 'S'                               # ASCII for uppercase 'S'
    beq $t7, $t6, handle_screen_output        # If choice is 'S', handle screen output

    li $t6, '4'                               # ASCII code for '4'
    beq $t7, $t6, handle_exit_program         # If choice is '4', handle program exit

    li $t6, 'e'                               # ASCII for lowercase 'e'
    beq $t7, $t6, handle_exit_program         # If choice is 'e', handle program exit

    li $t6, 'E'                               # ASCII for uppercase 'E'
    beq $t7, $t6, handle_exit_program         # If choice is 'E', handle program exit

    # If choice is invalid, print an error and redisplay the menu
    li $v0, 4                                 # Syscall for print string
    la $a0, invalidChoiceHandler              # Load address of the error message
    syscall
    j display_menu                            # Loop back to display the menu again

# Menu option handlers
handle_read_input:
    la $a0, FlagInputFile
    lb $t7, 0($a0)
    bne $t7, $zero, refresh_variables
    j handle_reading
refresh_variables:
    move $s7, $ra
    jal refresh
    move $ra, $s7
 
handle_reading:
    # Prompt for the input file and call read_input_file
    la $a0, printUserFileName                 # Load prompt for file input
    li $v0, 4
    syscall

    # Read the filename from the user
    la $a0, fileNameInputHandler                    # Address of fileNameInputHandler buffer
    li $a1, 64                                # Max characters to read
    li $v0, 8                                 # Syscall for reading string
    syscall

    # Trim newline character from the input filename
    la $a0, fileNameInputHandler                    # Address of filename
    jal trim_newline                          # Call trim_newline to clean up input

    # Call read_input_file to read and validate the file contents
    la $a0, fileNameInputHandler                    # Address of filename
    jal read_input_file                       # Call read_input_file procedure
    jal print_systems
    jal solve_systems
    la $a0, FlagInputFile
    li $t7, 1
    sb $t7, 0($a0)
    j display_menu                            # Return to menu after operation

handle_output_file:
    move $s7, $ra
    la $a0, FlagInputFile
    lb $t7, 0($a0)
    beqz $t7, not_ready_yet

    # Print the output filename prompt
    la $a0, fileNameOutputHandler   # Address of the prompt string
    li $v0, 4                       # Syscall for print string
    syscall

    # Read the output filename from the user
    la $a0, outFileNameHandler         # Address of the output filename buffer
    li $a1, 64                      # Max size of the filename
    li $v0, 8                       # Syscall for read string
    syscall

    # Trim the newline character from the output filename
    la $a0, outFileNameHandler         # Address of the filename string
    jal trim_newline                # Call the trim_newline procedure

    # Open the file for writing
    li $v0, 13                      # Syscall for open file
    la $a0, outFileNameHandler         # Address of the filename string
    li $a1, 1                       # Open in write mode
    li $a2, 644                     # File permissions (rw-r--r--)
    syscall
    move $t7, $v0                   # Store the file descriptor in $t7

    # Check if the file was opened successfully
    bltz $t7, file_open_error       # If file descriptor < 0, handle error
    
    #la $a3, outputHandler
    #jal count_buffer
    #move $ra, $s7
    
    # Write the output buffer to the file
    li $v0, 15                      # Syscall for write file
    move $a0, $t7                   # File descriptor
    la $a1, outputHandler           # Address of the buffer to write
    li $a2, 128
    syscall

    # Close the file
    li $v0, 16                      # Syscall for close file
    move $a0, $t7                   # File descriptor
    syscall

    j display_menu                  # Return to menu after operation
handle_screen_output:
    
    la $a0, FlagInputFile
    lb $t7, 0($a0)
    beqz $t7, not_ready_yet
    
    la $a0, outputHandler
    li $v0, 4
    syscall
    
    j display_menu                            # Return to menu after operation

not_ready_yet:
    la $a0, readInputFileFIRST
    li $v0, 4
    syscall
    j display_menu

handle_exit_program:
    # Code to exit the program
    li $v0, 10                                # Syscall for exit
    syscall

# Procedure to trim newline characters from the end of a string
# Input: $a0 - address of the string to be trimmed
# Output: None (modifies the string in place)
trim_newline:
    add $t7, $zero, $a0            # Copy the address of the string to $t7 for traversal

trim_loop:
    lb $t6, 0($t7)                 # Load the current character
    beq $t6, 0, end_trim           # If we reach the null terminator, we're done
    addi $t7, $t7, 1               # Move to the next character
    j trim_loop                    # Repeat until we reach the end of the string

# Backtrack to remove the newline character
end_trim:
    addi $t7, $t7, -1              # Go back one position to the last character
    lb $t6, 0($t7)                 # Load the last character
    li $t5, 10                     # ASCII value for newline character
    bne $t6, $t5, trim_done        # If it's not a newline, we're done
    sb $zero, 0($t7)               # Replace newline with null terminator if found

trim_done:
    jr $ra                          # Return from the procedure

# Error handling for format issues in equations
format_error:
    li $v0, 4                              # Syscall to print error message
    la $a0, equationErrorFormat                   # Load error message
    syscall
    j close_file                           # Close the file and return to menu

# Procedure to read and validate equations from an input file
# Input: $a0 - address of the filename string
# Output: None (modifies arrays for x, y, z coefficients, and results)
read_input_file:
    move $k1, $ra
    # Open the file in read mode
    li $v0, 13                             # Syscall for open file
    la $a0, fileNameInputHandler                 # Load the filename address
    li $a1, 0                              # Open in read-only mode
    li $a2, 0                              # Default permissions (not used in read-only mode)
    syscall
    move $s0, $v0                          # Store file descriptor in $s0

    # Check if file opened successfully
    bltz $s0, file_open_error              # If file descriptor < 0, handle file error

    # Read the entire file into buffer and parse as separate systems
    li $v0, 14                             # Syscall to read file
    move $a0, $s0                          # File descriptor
    la $a1, inputHandler                   # Address to load file contents
    li $a2, 500                            # Max characters to read
    syscall
    move $t7, $v0                          # Store read byte count

    # If end of file reached without reading, close file
    blez $t7, close_file

    # Call parse_systems to parse all systems in buffer
    la $a0, inputHandler                   # Address of buffer holding file contents
    jal parse_systems                      # Parse systems
    move $ra, $k1
    j close_file                           # Close file after reading

close_file:
    li $v0, 16                             # Syscall for close file
    move $a0, $s0                          # File descriptor
    syscall
    jr $ra                                 # Return to caller

file_open_error:
    # Print file read error message and exit
    li $v0, 4                              # Syscall for print string
    la $a0, erroReadingFile                # Load error message
    syscall
    j close_file                           # Go to close file and exit

# Procedure to parse multiple systems from buffer
# Input: $a0 - address of input buffer holding file contents
# Output: None (populates arrays for each system and equation)
parse_systems:
    move $k0, $ra
    # Initialize pointers and counters for parsing systems
    li $t9, 0                              # Reset system counter
    la $s1, XsCoeff                  # Initialize pointer to coefficient x array
    la $s2, YsCoeff                  # Initialize pointer to coefficient y array
    la $s3, ZsCoeff                  # Initialize pointer to coefficient z array
    la $s4, resultedArray                  # Initialize pointer to results array
    la $s5, isIt2or3Vars              # Initialize pointer to system types array
    li $t7, 0                              # Reset equation counter
    xor $t6, $t6, $t6                      # Clear readZ flag
    lb $t8, 0($a0)
    beqz $t8, parse_end
    lb $t9, sysCounter                 # Load current system counter
    addi $t9, $t9, 1                       # Increment system counter
    sb $t9, sysCounter                 # Store updated system counter
   
parse_line:
    lb $t8, 0($a0)                         # Load next character
    beqz $t8, parse_end                    # End of buffer reached, stop parsing

    # Handle new line (0xD 0xA) for separating systems and equations
    li $t0, 0xD                            # ASCII for carriage return
    beq $t8, $t0, check_line_feed          # If 0xD found, check next char
    li $t0, 0xA                            # ASCII for line feed
    beq $t8, $t0, handle_new_system        # If 0xA found, process as new system

    # Ignore spaces
    li $t0, ' '                            # ASCII for space
    beq $t8, $t0, next_char                # Skip spaces

    # Parse the line as an equation
    jal validate_and_parse_line            # Call line parser
    move $ra, $k0
    
    # Next line for parsing
    j next_char

check_line_feed:
    addi $a0, $a0, 1                       # Advance to next character
    lb $t8, 0($a0)                         # Load next character
    li $t0, 0xA                            # ASCII for line feed
    bne $t8, $t0, format_error             # If not 0xA, invalid line break

handle_new_system:
    addi $s5, $s5, 1                       # Advance system type pointer
    li $t7, 0                              # Reset equation counter
    lb $t9, sysCounter                 # Load current system counter
    addi $t9, $t9, 1                       # Increment system counter
    sb $t9, sysCounter                 # Store updated system counter
   
    j next_char                            # Continue to the next character

next_char:
    addi $a0, $a0, 1                       # Move to next character
    j parse_line                           # Continue parsing lines

parse_end:
    jr $ra                                 # Return to caller

# Procedure to validate and parse a single line for an equation
# Input: $a0 - address of input buffer line
# Output: Sets coefficients in arrays and indicates format errors
validate_and_parse_line:
    # Initialize flags for variables and signs
    sb $zero, readX                       # Clear readX flag
    sb $zero, readY                       # Clear readY flag
    sb $zero, readZ                       # Clear readZ flag
    sb $zero, reachEqual                  # Clear reachEqual flag
    li $t4, 0                              # Coefficient for x
    li $t3, 0                              # Coefficient for y
    li $t2, 0                              # Coefficient for z
    li $t1, 0                              # Result (right-hand side of equation)
    li $t0, 1                              # Default sign positive
    xor $t5, $t5, $t5                      # Clear current coefficient accumulator

parse_terms:
    lb $t8, 0($a0)                         # Load next character
    beqz $t8, validate_store               # End of line, validate and store results

    # Handle newline characters (0xD 0xA for end of equation)
    li $t9, 0xD                            # ASCII for carriage return
    beq $t8, $t9, check_line_feed1

    li $t9, 0xA                            # ASCII for line feed
    beq $t8, $t9, validate_store                # End of equation, validate and store

    # Ignore spaces
    li $t9, ' '                            # ASCII for space
    beq $t8, $t9, next_term                     # Skip spaces without error

    # Handle signs
    li $t9, '+'                            # ASCII for '+'
    beq $t8, $t9, set_positive

    li $t9, '-'                            # ASCII for '-'
    beq $t8, $t9, set_negative

    # Handle variables (x, y, z)
    li $t9, 'x'
    beq $t8, $t9, check_x                       # Process x variable

    li $t9, 'y'
    beq $t8, $t9, check_y                       # Process y variable

    li $t9, 'z'
    beq $t8, $t9, check_z                       # Process z variable

    # Handle equals sign
    li $t9, '='
    beq $t8, $t9, check_equals                  # Process equals sign

    # Handle digits
    li $t9, '0'
    bge $t8, $t9, check_digit_end          # Check if character is digit

    # Invalid character
    j format_error

set_positive:
    li $t0, 1                              # Set sign to positive
    j next_term

set_negative:
    li $t0, -1                             # Set sign to negative
    j next_term

check_digit_end:
    li $t9, '9'
    ble $t8, $t9, process_digit            # Process if character is digit
    j format_error                         # If not digit, format error

process_digit:
    sub $t8, $t8, '0'                      # Convert ASCII to integer
    mul $t5, $t5, 10                       # Shift previous value in $t5 by multiplying by 10
    add $t5, $t5, $t8                      # Add the new digit to $t5
    j next_term

check_x:
    lb $t9, readX                         # Check if x has already been read
    bne $t9, $zero, format_error           # If x already read, format error
    sb $t0, readX                         # Mark x as read
    beqz $t5, set_default_x                # If no value accumulated, default to 1
    mul $t4, $t5, $t0                      # Store coefficient for x
    j reset_accumulator

check_y:
    lb $t9, readY                         # Check if y has already been read
    bne $t9, $zero, format_error           # If y already read, format error
    sb $t0, readY                         # Mark y as read
    beqz $t5, set_default_y                # If no value accumulated, default to 1
    mul $t3, $t5, $t0                      # Store coefficient for y
    j reset_accumulator

check_z:
    lb $t9, readZ                         # Check if z has already been read
    bne $t9, $zero, format_error           # If z already read, format error
    sb $t0, readZ                         # Mark z as read
    beqz $t5, set_default_z                # If no value accumulated, default to 1
    mul $t2, $t5, $t0                      # Store coefficient for z
    j reset_accumulator

set_default_x:
    li $t5, 1                              # Default coefficient is 1
    mul $t4, $t5, $t0                      # Apply the sign and set the coefficient
    j reset_accumulator

set_default_y:
    li $t5, 1                              # Default coefficient is 1
    mul $t3, $t5, $t0                      # Apply the sign and set the coefficient
    j reset_accumulator
    
set_default_z:
    li $t5, 1                              # Default coefficient is 1
    mul $t2, $t5, $t0                      # Apply the sign and set the coefficient
    j reset_accumulator
    
reset_accumulator:
    xor $t5, $t5, $t5                      # Clear accumulator
    li $t0, 1                              # Reset sign
    j next_term

check_equals:
    lb $t9, reachEqual                    # Check if equals has already been read
    bne $t9, $zero, format_error           # If equals already read, format error
    sb $t0, reachEqual                    # Mark equals as read
    xor $t5, $t5, $t5                      # Clear accumulator
    li $t0, 1                              # Reset sign
    j next_term

check_line_feed1:
    addi $a0, $a0, 1                       # Advance to next character
    lb $t8, 0($a0)                         # Load next character
    li $t9, 0xA                            # ASCII for line feed
    bne $t8, $t9, format_error                  # If not 0xA, invalid line break
    j validate_store

next_term:
    addi $a0, $a0, 1                       # Advance to next character
    j parse_terms

validate_store:
    mul $t1, $t5, $t0
    # Validate that x and y are present
    lb $t8, readX
    beqz $t8, format_error                 # If x is missing, format error

    lb $t8, readY
    beqz $t8, format_error                 # If y is missing, format error

    # Determine system type based on readZ flag
    lb $t8, readZ
    beqz $t8, store_two_var                # If z is missing, it's a 2-variable system
    j store_three_var                      # If z is present, it's a 3-variable system

store_two_var:
    sb $zero, 0($s5)                       # Store system type as 0 (2-variable)
    j store_coefficients

store_three_var:
    li $t8, 1                              # System type for 3-variable system
    sb $t8, 0($s5)                         # Store system type as 1 (3-variable)
    
store_coefficients:
    sb $t4, 0($s1)                         # Store x coefficient
    sb $t3, 0($s2)                         # Store y coefficient
    sb $t2, 0($s3)                         # Store z coefficient
    sb $t1, 0($s4)                         # Store result
    addi $s1, $s1, 1                       # Advance x array pointer
    addi $s2, $s2, 1                       # Advance y array pointer
    addi $s3, $s3, 1                       # Advance z array pointer
    addi $s4, $s4, 1                       # Advance results array pointer
    jr $ra                                 # Return to caller
    
 
# Procedure to print all systems from the arrays
# Input: Coefficient arrays, system type array, and results array
# Output: Nicely formatted system equations
print_systems:
    la $t7, XsCoeff                  # Pointer to x coefficients
    la $t6, YsCoeff                  # Pointer to y coefficients
    la $t5, ZsCoeff                  # Pointer to z coefficients
    la $t4, resultedArray                  # Pointer to results
    la $t3, isIt2or3Vars              # Pointer to system types
    lb $t2, sysCounter                 # Load total number of systems
    li $t1, 0                              # System index starts at 1

    subi $t7, $t7, 1
    subi $t6, $t6, 1
    subi $t5, $t5, 1
    subi $t4, $t4, 1
    subi $t3, $t3, 1
print_systems_loop:
    addi $t7, $t7, 1
    addi $t6, $t6, 1
    addi $t5, $t5, 1
    addi $t4, $t4, 1
    addi $t3, $t3, 1
    
    bge $t1, $t2, print_systems_done
    addiu $t1, $t1, 1
    li $t8, 0
    
    la $a0, SysLabel
    li $v0, 4
    syscall
    
    li $v0, 1
    move $a0, $t1
    syscall
    
    li $v0, 4
    la $a0, newLineChar
    syscall
    
    lb $t0, 0($t3)
    beq $t0, 0, print_two_vars

print_three_vars:
    addiu $t8, $t8, 1
    lb $t9, 0($t7)
    beq $t9, 1, print_3x
    move $a0, $t9
    li $v0, 1
    syscall
print_3x:
    la $a0, XLabel
    li $v0, 4
    syscall
    
    la $a0, spaceChar
    syscall
    
    la $a0, pluseOp
    syscall
    
    la $a0, spaceChar
    syscall
    
    lb $t9, 0($t6)
    beq $t9, 1, print_3y
    move $a0, $t9
    li $v0, 1
    syscall
print_3y:
    la $a0, YLabel
    li $v0, 4
    syscall
    
    la $a0, spaceChar
    syscall
    
    la $a0, pluseOp
    syscall
    
    la $a0, spaceChar
    syscall
    
    lb $t9, 0($t5)
    beq $t9, 1, print_3z
    move $a0, $t9
    li $v0, 1
    syscall
print_3z:
    
    la $a0, ZLabel
    li $v0, 4
    syscall
    
    la $a0, equalsOp
    syscall
    
    lb $a0, 0($t4)
    li $v0, 1
    syscall
    
    la $a0, newLineChar
    li $v0, 4
    syscall
    beq $t8, 3, print_systems_loop
    addiu $t7, $t7, 1
    addiu $t6, $t6, 1
    addiu $t5, $t5, 1
    addiu $t4, $t4, 1
    j print_three_vars

print_two_vars:
    addiu $t8, $t8, 1
    lb $t9, 0($t7)
    beq $t9, 1, print_2x
    move $a0, $t9
    li $v0, 1
    syscall
print_2x:
    la $a0, XLabel
    li $v0, 4
    syscall
    
    la $a0, spaceChar
    syscall
    
    la $a0, pluseOp
    syscall
    
    la $a0, spaceChar
    syscall
    
    lb $t9, 0($t6)
    beq $t9, 1, print_2y
    move $a0, $t9
    li $v0, 1
    syscall
print_2y:
    la $a0, YLabel
    li $v0, 4
    syscall
    
    la $a0, equalsOp
    syscall
    
    lb $a0, 0($t4)
    li $v0, 1
    syscall
    
    la $a0, newLineChar
    li $v0, 4
    syscall
    
    beq $t8, 2, print_systems_loop
    addiu $t7, $t7, 1
    addiu $t6, $t6, 1
    addiu $t5, $t5, 1
    addiu $t4, $t4, 1
    j print_two_vars

print_systems_done:
    jr $ra
    
solve_systems:
    move $k0, $ra
    la $s0, XsCoeff                  # Initialize pointer to coefficient x array
    la $s1, YsCoeff                  # Initialize pointer to coefficient y array
    la $s2, ZsCoeff                  # Initialize pointer to coefficient z array
    la $s3, resultedArray                  # Initialize pointer to results array
    la $s4, isIt2or3Vars              # Initialize pointer to system types array
    la $a1, outputHandler
    li $s5, 0
check_system:
    
    lb $k1, sysCounter
    bge $s5, $k1, solving_done
    addiu $s5, $s5, 1
    
    lb $t7, 0($s4)
    beq $t7, 0, solve_two_vars
    
solve_three_vars:
        
    jal determinant_3x3      # find det(A)
    move $ra, $k0
    
    sw $v0, A_Determinant
    
    move $t7, $s0
    move $s0, $s3
    move $s3, $t7
    
    jal determinant_3x3     # find det(A1)
    move $ra, $k0
    
    sw $v0, A1_Determinant
    
    move $t7, $s0
    move $s0, $s3
    move $s3, $t7
    
    move $t7, $s1
    move $s1, $s3
    move $s3, $t7
    
    jal determinant_3x3    # find det(A2)
    move $ra, $k0
    
    sw $v0, A2_Determinant
    
    move $t7, $s1
    move $s1, $s3
    move $s3, $t7
    
    move $t7, $s2
    move $s2, $s3
    move $s3, $t7
    
    jal determinant_3x3
    move $ra, $k0
    
    sw $v0, A3_Determinant
    
    move $t7, $s2
    move $s2, $s3
    move $s3, $t7
    
    jal extract_three_var_answers
    move $ra, $k0
    
    addiu $s0, $s0, 3
    addiu $s1, $s1, 3
    addiu $s2, $s2, 3
    addiu $s3, $s3, 3
    addiu $s4, $s4, 1
    
    j check_system
  
solve_two_vars:
    
    jal determinant_2x2    # find det(A)
    move $ra, $k0
    
    sw $v0, A_Determinant
    
    move $t7, $s0
    move $s0, $s3
    move $s3, $t7
    
    jal determinant_2x2   # find det(A1)
    move $ra, $k0
    
    sw $v0, A1_Determinant
    
    move $t7, $s0
    move $s0, $s3
    move $s3, $t7
    
    move $t7, $s1
    move $s1, $s3
    move $s3, $t7
    
    jal determinant_2x2    # find det(A2)
    move $ra, $k0
    
    sw $v0, A2_Determinant
    
    move $t7, $s1
    move $s1, $s3
    move $s3, $t7
    
    jal extract_two_var_answers
    move $ra, $k0
    
    addiu $s0, $s0, 2
    addiu $s1, $s1, 2
    addiu $s2, $s2, 2
    addiu $s3, $s3, 2
    addiu $s4, $s4, 1
    j check_system

solving_done:
    jr $ra


extract_three_var_answers:
    move $t9, $ra
    li $a0, 'X'
    PRINT_VAR_RES $a0, $a1
    
    lw $t6, A_Determinant
    lw $t7, A1_Determinant
    
    jal division 
    move $ra, $t9
    
    move $a3, $v0
    
    la $a2, generalHandler
    jal string_reset
    move $ra, $t9
    
    la $a2, generalHandler
    move $v0, $a3
    
    jal parse_integer
    move $ra, $t9
    
    la $a2, generalHandler
    jal copy_string
    move $ra, $t9
    
    jal test_print_denominator
    move $ra, $t9
    
    li $a0, '\n'
    MOVE_MEM $a0, $a1
    
    li $a0, 'Y'
    PRINT_VAR_RES $a0, $a1
    
    lw $t6, A_Determinant
    lw $t7, A2_Determinant
    
    jal division 
    move $ra, $t9
    
    move $a3, $v0
    
    la $a2, generalHandler
    jal string_reset
    move $ra, $t9
    
    la $a2, generalHandler
    move $v0, $a3
    
    jal parse_integer
    move $ra, $t9
    
    la $a2, generalHandler
    
    jal copy_string
    move $ra, $t9
    
    jal test_print_denominator
    move $ra, $t9
    
    li $a0, '\n'
    MOVE_MEM $a0, $a1
    
    li $a0, 'Z'
    PRINT_VAR_RES $a0, $a1
    
    lw $t6, A_Determinant
    lw $t7, A3_Determinant
    
    jal division 
    move $ra, $t9
   
    move $a3, $v0
    
    la $a2, generalHandler
    jal string_reset
    move $ra, $t9
   
    move $v0, $a3
    la $a2, generalHandler
    jal parse_integer
    move $ra, $t9
    
    la $a2, generalHandler

    jal copy_string
    move $ra, $t9
    
    jal test_print_denominator
    move $ra, $t9
    
    li $a0, '\n'
    MOVE_MEM $a0, $a1
    MOVE_MEM $a0, $a1
    
    jr $ra


extract_two_var_answers:
    
    move $t9, $ra
    li $a0, 'X'
    PRINT_VAR_RES $a0, $a1
    
    lw $t6, A_Determinant
    lw $t7, A1_Determinant
    
    jal division 
    move $ra, $t9
    
    move $a3, $v0
    
    la $a2, generalHandler
    jal string_reset
    move $ra, $t9
    
    la $a2, generalHandler
    move $v0, $a3
    
    jal parse_integer
    move $ra, $t9
    
    la $a2, generalHandler
    jal copy_string
    move $ra, $t9
    
    jal test_print_denominator
    move $ra, $t9
    
    li $a0, '\n'
    MOVE_MEM $a0, $a1
    
    li $a0, 'Y'
    PRINT_VAR_RES $a0, $a1
    
    lw $t6, A_Determinant
    lw $t7, A2_Determinant
    
    jal division 
    move $ra, $t9
    
    move $a3, $v0
    
    la $a2, generalHandler
    jal string_reset
    move $ra, $t9
    
    la $a2, generalHandler
    move $v0, $a3
    
    jal parse_integer
    move $ra, $t9
    
    la $a2, generalHandler
    
    jal copy_string
    move $ra, $t9
    
    jal test_print_denominator
    move $ra, $t9
    
    li $a0, '\n'
    MOVE_MEM $a0, $a1
    MOVE_MEM $a0, $a1
    
    jr $ra

test_print_denominator:
    move $t0, $ra
    
    beq $v1, 1, no_print_needed
    li $a0, '/'
    MOVE_MEM, $a0, $a1
    
    la $a2, generalHandler
    jal string_reset
    move $ra, $t0
    
    la $a2, generalHandler
    move $v0, $v1
    
    jal parse_integer
    move $ra, $t0
    
    la $a2, generalHandler
    
    jal copy_string
    move $ra, $t0
    
no_print_needed:
    jr $ra

# Function to do division
# Input: $t7 = dividend, $t6 = divisor
# Output:
#   $v0 = numerator (or integer result if exact division)
#   $v1 = denominator (0 if exact division)
division:
    move $t8, $ra           # Save return address
    beqz $t6, division_by_zero_error  # Check for division by zero
    
    # Perform division to check if the result is exact
    div $t7, $t6
    
    mfhi $t5                # Get the remainder
    mflo $v0                # Get the quotient
    
    beqz $t5, exact_division # If remainder is 0, it's an exact division

    # Handle fractional division
    move $v0, $t7           # Numerator
    move $v1, $t6           # Denominator
    move $t2, $t6
    # Compute GCD of numerator and denominator
    jal gcd                 # Call GCD procedure
    move $ra, $t8           # Restore return address

    # Simplify the fraction
    div $v0, $v0, $v1       # Divide numerator by GCD
    mflo $v0
    div $v1, $t2, $v1       # Divide denominator by GCD
    mflo $v1
    jr $ra                  # Return to the caller

exact_division:
    li $v1, 1               # Denominator set to 0
    jr $ra                  # Return to the caller

division_by_zero_error:
    # Handle division by zero error (optional error handling)
    li $v0, 4
    la $a0, divisionByZero  # Load error message
    syscall
    li $v0, 10              # Exit program
    syscall

# Procedure to calculate GCD using the Euclidean algorithm
# Input: $v0 = numerator, $v1 = denominator
# Output: $v1 = GCD of numerator and denominator
gcd:
    move $t7, $v0           # Copy numerator to $t7
    move $t6, $v1           # Copy denominator to $t6

gcd_loop:
    beqz $t6, gcd_done      # If $t6 is 0, GCD is in $t7
    div $t7, $t6
    mfhi $t5                # Get the remainder
    move $t7, $t6           # $t7 = $t6
    move $t6, $t5           # $t6 = remainder
    j gcd_loop

gcd_done:
    move $v1, $t7           # GCD is in $t7
    jr $ra                  # Return to the caller



# Function to calculate determinant for 3x3 matrix
# Input: $s0 = pointer to first col, $s1 = pointer to second col, $s2 = pointer to third col
# Output: $v0 = determinant value
determinant_3x3:
    move $k1, $ra
    
    lb $t7, 0($s0)
    
    lb $t6, 1($s1)
    lb $t5, 1($s2)
    lb $t4, 2($s1)
    lb $t3, 2($s2)
    
    jal determinant_2x2_3x3
    move $ra, $k1
    
    mult $t7, $t6
    mflo $t0        
    
    lb $t7, 0($s1)
    
    lb $t6, 1($s0)
    lb $t5, 1($s2)
    lb $t4, 2($s0)
    lb $t3, 2($s2)
    
    jal determinant_2x2_3x3
    move $ra, $k1
    
    mult $t7, $t6
    mflo $t8
    
    lb $t7, 0($s2)
    
    lb $t6, 1($s0)
    lb $t5, 1($s1)
    lb $t4, 2($s0)
    lb $t3, 2($s1)
    
    jal determinant_2x2_3x3
    move $ra, $k1
    
    mult $t7, $t6
    mflo $t9
    
    sub $v0, $t0, $t8
    add $v0, $v0, $t9
    
    jr $ra             # Return to caller

# $t6   $t5 
# $t4   $t3
determinant_2x2_3x3:
    mult $t6, $t3
    mflo $t2
    mult $t4, $t5
    mflo $t1
    
    sub $t6, $t2, $t1
    jr $ra

# Function to calculate determinant for 2x2 matrix
# Input: $s0 = pointer to first col, $s1 = pointer to second col
# Output: $v0 = determinant value
determinant_2x2:
    
    lb $t7, 0($s0)
    lb $t6, 0($s1)
    lb $t5, 1($s0)
    lb $t4, 1($s1)
    
    mult $t7, $t4
    mflo $t7
    
    mult $t6, $t5
    mflo $t6
    
    sub $v0, $t7, $t6
    
    jr $ra


# Function to reset a string
# Input: $a2 = pointer to the target string
# Output: string is empty
string_reset:

loop_reset:
    lb $t8, 0($a2)
    beqz $t8, reset_string_done
    sb $zero, 0($a2)
    addiu $a2, $a2, 1
    addiu $t1, $t1, 1
reset_string_done:
    jr $ra


# Procedure to copy a null-terminated string
# Input: 
#   $a2 - address of the source string
#   $a1 - address of the destination string
# Output:
#   Copies the null-terminated string from $a2 to $a1
copy_string:
    loop_copy:
        lb $t7, 0($a2)      # Load a byte from the source string
        sb $t7, 0($a1)      # Store the byte into the destination string
        beq $t7, $zero, done_copy # If null terminator is encountered, end copy
        addiu $a2, $a2, 1   # Move to the next byte in the source string
        addiu $a1, $a1, 1   # Move to the next byte in the destination string
        j loop_copy         # Repeat for the next byte
    
    done_copy:
        jr $ra              # Return to the caller


# Function to parse an integer into a string
# Input: $v0 contains the integer, $a2 contains the address of the string buffer
# Output: The integer is converted to a string at the address in $a2
parse_integer:
    move $t7, $v0           # Copy the input integer to $t7
    li $t6, 0               # Initialize digit counter
    li $t5, 0               # Flag for negative number (0 = positive, 1 = negative)

    # Handle negative numbers
    bltz $t7, handle_negative

convert_integer:
    beqz $t7, handle_zero   # If $t7 is zero, handle the special case
    divu $t7, $t7, 10       # Divide the number by 10
    mfhi $t4                # Get the remainder (last digit)
    addiu $t4, $t4, '0'     # Convert digit to ASCII
    sb $t4, 0($a2)          # Store the digit as a character
    addiu $a2, $a2, 1       # Move pointer forward in the buffer
    mflo $t7                # Update $t7 with the quotient
    addiu $t6, $t6, 1       # Increment digit counter
    bnez $t7, convert_integer # Repeat until $t7 becomes zero

    # Handle negative number case
    bnez $t5, add_minus_sign
    j finalize_string

handle_negative:
    li $t5, 1               # Set negative flag
    subu $t7, $zero, $t7    # Make the number positive
    j convert_integer

add_minus_sign:
    li $t4, '-'             # Load ASCII for minus sign
    sb $t4, 0($a2)          # Store the minus sign
    addiu $a2, $a2, 1       # Move pointer forward in the buffer

finalize_string:
    sb $zero, 0($a2)        # Null-terminate the string
    sub $a2, $a2, $t6       # Move pointer back to the start of the string
    bnez $t5, adjust_pointer # Adjust for negative sign if present
    jr $ra                  # Return to the caller

adjust_pointer:
    sub $a2, $a2, 1         # Include the minus sign in the pointer adjustment
    jr $ra

handle_zero:
    li $t4, '0'             # ASCII for '0'
    sb $t4, 0($a2)          # Store '0' in the buffer
    addiu $a2, $a2, 1       # Move pointer forward
    j finalize_string

count_buffer:
    li $a2, 5   
count_loop:
    lb $t7, 0($a3)
    beqz $t7, counting_done
    addiu $a2, $a2, 1
    addiu $a3, $a3, 1
    j count_loop
counting_done:     
    jr $ra

refresh:
    move $s6, $ra
    
    la $a2, fileNameInputHandler
    jal string_reset
    la $a2, outFileNameHandler
    jal string_reset
    la $a2, inputHandler
    jal string_reset
    la $a2, outputHandler
    jal string_reset
    la $a0, FlagInputFile
    li $t7, 0
    sb $t7, 0($a0)
    sb $t7, sysCounter
    
    jr $s6
